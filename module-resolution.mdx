# 브라우저와 TypeScript의 모듈 해석 방식 차이

TypeScript에서 `paths` 옵션을 사용해 **절대 경로(alias)**로 import를 작성했을 때,  
순수 TypeScript 컴파일러(`tsc`)만 사용하면 브라우저에서 모듈을 찾지 못하는 문제가 발생한다.

이 문제를 이해하려면 **브라우저와 TypeScript가 모듈을 찾는 기준이 완전히 다르다**는 점을 구분해야 한다.

---

## 핵심 요약

- 브라우저는 **URL 기준**으로만 모듈을 찾는다.
- TypeScript의 alias(`paths`)는 **타입 해석용 기능**이다.
- `tsc`는 import 경로를 변환하지 않는다.
- alias를 런타임에서 사용하려면 **번들러 또는 별도 로더가 필요하다**.

---

## 1. 브라우저의 모듈 해석 방식 (런타임)

브라우저는 **ES Module을 URL 기반으로 로딩**한다.

```js
import { foo } from './utils.js'
```

브라우저가 이해하는 경로는 다음뿐이다.

- 상대 경로 (`./`, `../`)
- 절대 URL (`/utils.js`, `https://example.com/utils.js`)

브라우저 입장에서는 import 문자열을 **그대로 URL로 해석**하며,  
파일 시스템이나 `tsconfig.json` 같은 개념은 전혀 알지 못한다.

```js
import { foo } from '@/utils'
```

위 코드는 브라우저 입장에서:

1. `"@/utils"` → URL 아님
1. 상대 경로 아님
1. 해석 불가 → **모듈 로드 실패**

즉, **브라우저에는 alias라는 개념 자체가 없다.**

---

## 2. TypeScript의 모듈 해석 방식 (컴파일 타임)

TypeScript는 실행을 담당하지 않는다.  
TypeScript의 역할은 다음에 한정된다.

1. 타입 검사
1. TS → JS 문법 변환
1. 'import 대상이 어떤 타입을 의미하는지 해석'

이를 위해 `tsconfig.json`의 `paths` 옵션을 제공한다.

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

이 설정의 목적은 오직 하나다.

> **“이 import가 어떤 타입 선언을 가리키는지 알려주기 위함”**

중요한 점은 다음이다.

- `paths`는 **타입 해석용 규칙**
- 런타임 경로 변환 ❌
- JS 코드의 import 문자열 변경 ❌

```ts
// TypeScript
import { foo } from '@/utils'
```

```js
// tsc 컴파일 결과
import { foo } from '@/utils'
```

TypeScript 컴파일러는 **import specifier를 그대로 유지**한다.

---

## 3. 왜 순수 tsc 환경에서는 alias가 동작하지 않는가?

- TypeScript는 alias를 **타입을 찾기 위해서만** 사용
- `tsc`는 import 경로를 실제 파일 경로로 변환하지 않음
- 브라우저는 alias를 URL로 해석할 수 없음

따라서,

> **순수 TypeScript 컴파일러만 사용하는 경우,  
> alias는 브라우저 입장에서는 “존재하지 않는 경로”가 된다.**

---

## 4. 그럼 alias는 언제 동작하는가?

alias가 정상 동작하는 환경에는 항상 **중간 단계**가 존재한다.

### 번들러가 있는 경우

- Vite
- Webpack
- Rollup
- Next.js

이 도구들의 역할은 다음과 같다.

```text
"@/utils" -> (번들러) -> "./src/utils.js" -> 브라우저가 이해 가능한 URL
```

즉, **번들러가 alias를 실제 경로로 변환해 주기 때문에**
브라우저에서 문제없이 동작하는 것이다.

---

## 5. 순수 tsc + 브라우저 환경에서의 선택지

1. **상대 경로만 사용**

```ts
import { foo } from '../../utils'
```

2. **Node.js 런타임 전용 로더 사용**

- `ts-node`
- `tsconfig-paths`
  → 브라우저 환경에서는 사용 불가

3. **Import Map 사용 (브라우저)**

```html
<script type="importmap">
  {
    "imports": {
      "@/": "/src/"
    }
  }
</script>
```

- 지원 범위 제한
- 실무 활용도 낮음

4. **tsc-alias 같은 도구 사용**
   [tsc-alias](https://www.npmjs.com/package/tsc-alias) 도구를 사용해  
   `tsc` 컴파일 후 alias를 실제 경로로 변환할 수 있다.

   ```bash
   "scripts": {
        "build": "tsc && tsc-alias",
   }
   ```

   1. 1단계: tsc (TypeScript Compiler)

      tsconfig.json 을 보고 타입을 검사하고 .ts 를 .js로 변환  
      중요한 점: tsc는 경로(paths)를 건드리지 않습니다. 그냥 ~/utils라고 적혀 있으면 JS 파일에도 그대로 ~/utils라고 적어서 내보냄 (브라우저 에러 발생)

   2. 2단계: tsc-alias (Post-Compile Tool)

      tsc가 만든 js 파일들을 순회하며, tsconfig.json의 paths 설정을 읽어봅니다. ("아, ~는 src/ 폴더를 가리키는구나!")  
      방금 만들어진 JS 파일들을 하나하나 열어서 ~/utils를 ../utils/index.js 처럼 상대 경로 변경

---

## 한 문장 요약

TypeScript의 path alias는 컴파일 타임의 타입 해석을 위한 기능이며,  
순수 tsc는 import 경로를 실제 파일 경로로 변환하지 않아 브라우저에서  
실행 시 alias는 URL이 아니기 때문에 모듈을 찾지 못한다.
