# 브라우저와 TypeScript의 모듈 해석 방식 차이

TypeScript에서 `paths` 옵션을 사용해 **절대 경로(alias)**로 import를 작성했을 때,  
순수 TypeScript 컴파일러(`tsc`)만 사용하면 브라우저에서 모듈을 찾지 못하는 문제가 발생한다.

이 문제를 이해하려면 **브라우저와 TypeScript가 모듈을 찾는 기준이 완전히 다르다**는 점을 구분해야 한다.

---

## 핵심 요약

- 브라우저는 **URL 기준**으로만 모듈을 찾는다.
- TypeScript의 alias(`paths`)는 **타입 해석용 기능**이다.
- `tsc`는 import 경로를 변환하지 않는다.
- alias를 런타임에서 사용하려면 **번들러 또는 별도 로더가 필요하다**.

---

## 1. 브라우저의 모듈 해석 방식 (런타임)

브라우저는 **ES Module을 URL 기반으로 로딩**한다.

```js
import { foo } from './utils.js'
```

브라우저가 이해하는 경로는 다음뿐이다.

- 상대 경로 (`./`, `../`)
- 절대 URL (`/utils.js`, `https://example.com/utils.js`)

브라우저 입장에서는 import 문자열을 **그대로 URL로 해석**하며,  
파일 시스템이나 `tsconfig.json` 같은 개념은 전혀 알지 못한다.

```js
import { foo } from '@/utils'
```

위 코드는 브라우저 입장에서:

1. `"@/utils"` → URL 아님
1. 상대 경로 아님
1. 해석 불가 → **모듈 로드 실패**

즉, **브라우저에는 alias라는 개념 자체가 없다.**

---

## 2. TypeScript의 모듈 해석 방식 (컴파일 타임)

TypeScript는 실행을 담당하지 않는다.  
TypeScript의 역할은 다음에 한정된다.

1. 타입 검사
1. TS → JS 문법 변환
1. 'import 대상이 어떤 타입을 의미하는지 해석'

이를 위해 `tsconfig.json`의 `paths` 옵션을 제공한다.

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

이 설정의 목적은 오직 하나다.

> **“이 import가 어떤 타입 선언을 가리키는지 알려주기 위함”**

중요한 점은 다음이다.

- `paths`는 **타입 해석용 규칙**
- 런타임 경로 변환 ❌
- JS 코드의 import 문자열 변경 ❌

```ts
// TypeScript
import { foo } from '@/utils'
```

```js
// tsc 컴파일 결과
import { foo } from '@/utils'
```

TypeScript 컴파일러는 **import specifier를 그대로 유지**한다.

---

## 3. 왜 순수 tsc 환경에서는 alias가 동작하지 않는가?

- TypeScript는 alias를 **타입을 찾기 위해서만** 사용
- `tsc`는 import 경로를 실제 파일 경로로 변환하지 않음
- 브라우저는 alias를 URL로 해석할 수 없음

따라서,

> **순수 TypeScript 컴파일러만 사용하는 경우,  
> alias는 브라우저 입장에서는 “존재하지 않는 경로”가 된다.**

---

### 4. alias는 언제, 어떻게 “동작”하는가?

여기서 말하는 “동작”은 런타임에서 `@/…` 같은 문자열을 브라우저가 이해할 수 있는 실제 URL/경로로 변환하는 과정을 의미한다.
이 변환은 브라우저가 아니라 중간 도구(번들러/개발 서버/후처리 도구)가 수행한다.

- 브라우저: alias 개념이 없어, 문자열을 그대로 URL로 해석
- TypeScript(tsc): `paths`로 타입만 찾고, import 문자열은 그대로 유지

- 번들러/개발 서버(Vite, Webpack, Rollup, Next.js 등): 설정된 `resolve.alias`에 따라 **import 경로를 실제 파일 위치로 재작성**하거나 **가상 모듈로 매핑**해 런타임에서 로드 가능하게 함
- 후처리 도구(tsc-alias 등): tsc 출력 JS를 후처리하여 **상대 경로로 치환**

```text
"@/utils" -> (번들러/후처리 도구) -> "./src/utils.js" -> 브라우저가 이해 가능한 URL
```

즉, alias가 “동작”하려면 **런타임 해석 단계**가 반드시 필요하다.  
보통은 번들러 설정에 tsconfig의 alias와 동일한 매핑을 추가한다.

예시(설정 일치가 핵심):

```json
// tsconfig.json — 타입 해석용
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

```js
// vite.config.js — 런타임 해석용(개발/빌드)
import { defineConfig } from 'vite'
import path from 'path'

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  }
})
```

- “alias가 있다”는 말은 곧 “도구가 그 문자열을 **실제 경로/URL로 변환**한다”는 뜻이다.
- tsconfig의 `paths`만으로는 브라우저에서 작동하지 않는다. 번들러(혹은 후처리) 설정이 있어야 한다.
- 개발과 빌드 모두에서 동작시키려면 두 환경의 alias 설정을 **동일하게 유지**해야 한다.

---

## 5. 순수 tsc + 브라우저 환경에서의 선택지

1. **상대 경로만 사용**

```ts
import { foo } from '../../utils'
```

2. **Node.js 런타임 전용 로더 사용**

- `ts-node`
- `tsconfig-paths`
  → 브라우저 환경에서는 사용 불가

3. **Import Map 사용 (브라우저)**

```html
<script type="importmap">
  {
    "imports": {
      "@/": "/src/"
    }
  }
</script>
```

- 지원 범위 제한
- 실무 활용도 낮음

4. **tsc-alias 같은 도구 사용**
   [tsc-alias](https://www.npmjs.com/package/tsc-alias) 도구를 사용해  
   `tsc` 컴파일 후 alias를 실제 경로로 변환할 수 있다.

   ```bash
   "scripts": {
        "build": "tsc && tsc-alias",
   }
   ```

   1. 1단계: tsc (TypeScript Compiler)

      tsconfig.json 을 보고 타입을 검사하고 .ts 를 .js로 변환  
      중요한 점: tsc는 경로(paths)를 건드리지 않습니다. 그냥 ~/utils라고 적혀 있으면 JS 파일에도 그대로 ~/utils라고 적어서 내보냄 (브라우저 에러 발생)

   2. 2단계: tsc-alias (Post-Compile Tool)

      tsc가 만든 js 파일들을 순회하며, tsconfig.json의 paths 설정을 읽어봅니다. ("아, ~는 src/ 폴더를 가리키는구나!")  
      방금 만들어진 JS 파일들을 하나하나 열어서 ~/utils를 ../utils/index.js 처럼 상대 경로 변경

---

## 한 문장 요약

TypeScript의 path alias는 컴파일 타임의 타입 해석을 위한 기능이며,  
순수 tsc는 import 경로를 실제 파일 경로로 변환하지 않아 브라우저에서  
실행 시 alias는 URL이 아니기 때문에 모듈을 찾지 못한다.
