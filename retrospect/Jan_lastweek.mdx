## AI 질문 실패 사례: 캐싱 설계에서 놓친 질문 하나

### 배경

퍼블리싱 프로젝트에서 계정별 권한에 따라 메뉴 접근을 제한하기 위해
서버에서 메뉴 리스트를 내려주는 구조를 사용하고 있었다.

### 기존 구조

- 새로고침 시 서버에서 메뉴 리스트 요청
- 약 1초간 스피너 노출 후 메뉴 렌더링
- 메뉴 구조는 자주 변경되지 않음

👉 불필요한 서버 호출을 줄이고, 초기 렌더링 속도를 개선하고 싶었다.

### 내가 세운 개선 방향

- 메뉴 데이터는 자주 바뀌지 않으므로 캐싱이 적합
- 새로고침 시에도 캐시된 데이터로 빠르게 렌더링되면 UX 개선 가능

### 기술 선택 후보

1. react-query + 전역 상태관리 라이브러리(persist)
2. react-query의 persistAsyncStorage 사용

### 판단 기준

- 필요한 데이터만 선별적으로 로컬 스토어에 저장할 수 있어야 한다
- 다른 개발자들도 쉽게 사용할 수 있어야 한다 (복잡하지 않게)

⸻

### 내가 내린 선택

- react-query에서 이미 서버 상태를 관리하고 있으므로
  이를 다시 전역 상태로 복제하는 것은 비효율적이라고 판단
- persistAsyncStorage를 사용하여:
- Provider 레벨에서 persist 설정
- useQuery / mutate의 meta.persist = true 옵션으로
  원하는 데이터만 선택적으로 저장

👉 설계상으로는 깔끔하고 사용성도 좋아 보였다.

⸻

### 문제가 드러난 지점 (실패)

구현 이후 다음 문제를 발견했다.

- 캐싱된 데이터를 선택적으로 제거하거나 강제로 갱신할 수 있는 방법이 없음
- 로컬 스토어 초기화를 하려면 전체 데이터를 삭제해야만 하는 구조
- 권한 변경, 계정 변경, 운영 이슈 발생 시
- “이 메뉴 캐시만 지운다”가 불가능

👉 즉, 운영 단계에서 필요한 ‘캐시 무효화 전략’이 설계에 포함되지 않았다.

⸻

### 왜 이 판단이 실패였는가 (핵심 원인)

기술 조사나 이해 부족의 문제가 아니었다.

진짜 원인

AI에게 ‘성공 조건’만 질문하고
‘실패/운영 조건’을 질문하지 않았다.

    •	캐싱을 쓰는 이유
    •	사용성
    •	구현 난이도

👉 이런 성공 시나리오 중심으로만 판단함

하지만 캐싱은:

- 언제 갱신해야 하는지
- 언제 제거해야 하는지
- 운영 중 어떤 상황에서 깨질 수 있는지
  를 함께 고려해야 하는 운영 기능이었다.

⸻

### 여기서 얻은 교훈

❌ 잘못된 질문 방식

“이 상황에서 어떤 캐싱 방식을 쓰는 게 좋을까?”

✅ 더 나은 질문 방식

“이 캐싱 설계가 운영 중 실패할 수 있는 시나리오는 무엇이고,
그때 어떤 무효화 전략이 필요한가?”

⸻

### 앞으로 적용할 질문 체크리스트

캐싱 / persist / 전역 상태를 고민할 때, 기술 선택 전에 반드시 질문할 것

1. 이 데이터는 언제 갱신되어야 하는가?
2. 갱신 트리거는 누가 발생시키는가? (유저 / 관리자 / 서버)
3. 부분 삭제가 필요한가, 전체 삭제면 충분한가?
4. 배포/권한 변경/계정 전환 시 캐시는 어떻게 동작해야 하는가?

👉 이 질문에 답이 없으면, 기술 선택을 보류한다.
